/*
This is an example implementation of consensus.Engine() interface.
Serving as an example of how to create a custom consensus engine to use the Cunner framework.


Engine Struct
Represents the solo consensus engine. Key fields:
blockGenerationInterval: Time between block proposals
relayCh: Channel for relaying messages (blocks) to the server
transactions: Buffer for pending transactions
Configurate Method
Called by the server on startup. Sets up the engine's private key and relay channel, then starts the run goroutine.
run Method
Goroutine that periodically proposes new blocks:
1. Wait for blockGenerationInterval
2. Create new block with pending transactions
3. Send block message to relayCh
4. Increment block index and clear transaction buffer
AddTransaction Method
Adds a new transaction to the pending buffer. Called by the server when it receives a transaction message.
Integration with Consenter
The solo engine is used as follows:
1. Server is configured to use the solo engine:
engine := solo.NewEngine(interval)
srv := network.NewServer(cfg, engine)
2. On startup, the server calls engine.Configurate, passing the relay channel and private key.
3. The server calls engine.AddTransaction when it receives a new transaction message.
4. The solo engine periodically proposes blocks and sends them to the server via the relay channel.
5. The server broadcasts the block messages to connected peers.
*/

use tokio::time::{self, Duration, Instant};
use ecdsa::SigningKey;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;

// these are generated by `prost` from message.proto file
use crate::messages::{Message, Transaction, NewBlock};

/// Engine represents a single consensus engine. This is used as an implementation example.
pub struct Engine {
    block_generation_interval: Duration,
    private_key: Option<Arc<SigningKey>>,
    relay_channel: Option<mpsc::Sender<Message>>,
    transactions: Arc<Mutex<Vec<Transaction>>>,
}

impl Engine {
    /// Returns a new solo consensus engine.
    pub fn new(interval: Duration) -> Arc<Mutex<Self>> {
        Arc::new(Mutex::new(Self {
            block_generation_interval: interval,
            private_key: None,
            relay_channel: None,
            transactions: Arc::new(Mutex::new(vec![])),
        }))
    }

    /// Configures the engine with a relay channel and a private key.
    pub fn configurate(&mut self, relay_channel: mpsc::Sender<Message>, private_key: Arc<SigningKey>) {
        self.private_key = Some(private_key);
        self.relay_channel = Some(relay_channel);
        let engine_clone = self.clone();
        tokio::spawn(async move {
            engine_clone.run().await;
        });
    }

    /// The main loop that runs the engine, generating blocks at intervals.
    async fn run(&self) {
        let mut interval = time::interval(self.block_generation_interval);
        let mut index: u32 = 0;

        loop {
            interval.tick().await;
            let transactions = self.transactions.lock().unwrap().clone();
            let block = NewBlock(index, transactions);
            if let Some(ref relay_channel) = self.relay_channel {
                relay_channel.send(Message::from_block(block)).await.unwrap();
            }
            index += 1;
            self.transactions.lock().unwrap().clear();
        }
    }

    /// Adds a transaction to the engine.
    pub fn add_transaction(&self, tx: Transaction) {
        let mut transactions = self.transactions.lock().unwrap();
        transactions.push(tx);
    }
}

impl Clone for Engine {
    fn clone(&self) -> Self {
        Self {
            block_generation_interval: self.block_generation_interval,
            private_key: self.private_key.clone(),
            relay_channel: self.relay_channel.clone(),
            transactions: self.transactions.clone(),
        }
    }
}

