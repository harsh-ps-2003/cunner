mod consensus {
    pub mod example {
        pub mod engine;
    }
    pub mod engine;
    pub mod avalanche {
        pub mod engine;
    }
}

mod network {
    pub mod peer;
    pub mod messages {
        pub mod message; // generated by protobuf
        pub mod messages;
        pub mod protobuf;
    }
}

mod storage {
    pub mod store;
}

use clap::{Parser, Subcommand, ValueEnum};
use consensus::engine::Engine;
use log::{debug, error, info};
use network::peer::run_peer;
use std::sync::{Arc, Mutex};
use std::time::Duration;
use thiserror::Error;
use tracing_subscriber::EnvFilter;

#[derive(Parser)]
#[command(about = "Pluggable blockchain consensus simulation framework", long_about = None)]

struct Cli {
    #[command(subcommand)]
    command: Commands,
}

// how will the commands work, how will multiple nodes work!
#[derive(Subcommand)]
enum Commands {
    /// Start a single cunner node
    Node {
        #[arg(long, help = "TCP address to bind to")]
        tcp: Option<u16>,
        // #[arg(long, help = "Private key for the node for creating the transaction")]
        // private_key: Option<secp256k1::SecretKey>,
        #[arg(long, help = "Consensus engine to use")]
        engine: Option<DefinedEngines>,
    },
}

#[derive(Clone, ValueEnum, Debug)]
enum DefinedEngines {
    Example,
    Avalanche, // TODO: engine not implemented
               // add more of your own!
}

#[derive(Debug)]
pub struct PeerConfig {
    tcp_listen_address: Option<u16>,
    // private_key: Option<secp256k1::SecretKey>,
}

#[derive(Error, Debug)]
pub enum CunnerError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Engine error: {0}")]
    Engine(String),
    #[error("Network error: {0}")]
    Network(String),
    #[error("Configuration error: {0}")]
    Config(String),
    #[error("Logging initialization error: {0}")]
    LogInit(#[from] log::SetLoggerError),
}

fn main() -> Result<(), CunnerError> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Node {
            tcp,
            // private_key,
            engine,
        } => {
            info!("Starting peer with TCP: {:?}, Engine: {:?}", tcp, engine);
            start_peer(tcp, engine)?;
        }
    }

    Ok(())
}

// initializes the consensus engine based on the provided option, sets up the peer configuration, and starts the network operations.
fn start_peer(
    tcp: Option<u16>,
    // private_key: Option<secp256k1::SecretKey>,
    engine: Option<DefinedEngines>,
) -> Result<(), CunnerError> {
    let engine_instance: Arc<Mutex<Option<Box<dyn Engine>>>> = Arc::new(Mutex::new(None));

    // let private_key = private_key.ok_or("missing private key for consensus node")?;

    match engine {
        Some(DefinedEngines::Example) => {
            debug!("Initializing Example engine");
            let mut engine_guard = engine_instance
                .lock()
                .map_err(|e| CunnerError::Engine(format!("Failed to lock engine: {}", e)))?;
            *engine_guard = Some(consensus::example::engine::Engine::new_engine(
                Duration::from_secs(15),
            ));
        }
        None => {
            return Err(CunnerError::Config(
                "Engine cannot be empty if running a consensus node".into(),
            ))
        }
        _ => return Err(CunnerError::Config("Invalid engine option".into())),
    }

    let peer_configuration = PeerConfig {
        tcp_listen_address: Some(tcp.unwrap_or(0)),
        // private_key: Some(private_key),
    };

    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .try_init()
        .map_err(|e| {
            CunnerError::Config(format!("Failed to initialize tracing subscriber: {}", e))
        })?;

    info!("Starting peer with configuration: {:?}", peer_configuration);

    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .map_err(CunnerError::Io)?
        .block_on(run_peer(peer_configuration, engine_instance))
        .map_err(|e| CunnerError::Network(e.to_string()))?;

    Ok(())
}
